# finalizer와 cleaner 사용을 피하라

## 자바는 두 가지 객체 소멸자를 제공한다.

1. finalizer
   - 예측할 수 없다.
   - 상황에 따라서 위험할 수 있다.
   - 일반적으로 불필요하다.
2. cleaner - finalizer보다는 덜 위험하지만 여전히 예측할 수 없다. - 느리다. - 일반적으로 불필요하다.
   > C++ 프로그래머라면 주의해야한다. 자바의 finalizer와 cleaner는 C++의 파괴자(destructor)와 다른 개념이다. C++에서 파괴자는 특정 객체와 관련된 자원을 회수하는 보편적인 방법이다. 자바에서는 접근할 수 없게 된 객체를 회수하는 역할을 가비지 컬렉터가 담당하고, 프로그래머에게는 아무런 작업도 요구하지 않는다. C++의 파괴자는 비메모리 자원을 회수하는 용도로도 쓰인다. 하지만 자바에서는 `try-with-resource`와 `try-finally`를 사용해 해결한다(아이템 9).

### finalizer와 cleaner는 즉시 수행된다는 보장이 없다.

- 객체에 접근할 수 없게된 후 finalizer와 cleaner는 즉시 수행된다는 보장이 없다.
- 객체에 접근할 수 없게 된 후 finalizer나 cleaner에게 맡기면 중대한 오류를 이르킬 수 있다.
  - 시스템이 동시에 열 수 있는 파일 개수에 한계가 있기 때문이다.
- finalizer나 cleaner가 얼마나 신속히 수행할지는 전적으로 가비지 컬렉터 알고리즘에 달려있다.
- 자바 언어 명세에는 finalizer나 cleaner의 수행 시점뿐 아니라 수행 여부조차 보장하지 않는다.

### 프로그램 생에주기와 상관없는, 상태를 영구적으로 수정하는 작업에서는 절대 finalizer나 cleaner에 의존해서는 안된다.

- 예를 들어 데이터베이스 같은 공유 자원의 영구 락(lock) 해제를 finalizer나 cleaner에게 맡겨 놓으면 분산 시스템 전체가 서서히 멈출 것이다.

### System.gc나 System.runFinalization 메서드에 현혹되지 말자.

- finalizer와 cleaner가 실행될 가능성을 높여줄 수 는 있으나, 보장해주진 않는다.

### finalizer와 cleaner는 심각한 성능 문제도 동반한다.

### finalizer를 사용한 클래스는 finalizer 공격에 노출되어 심각한 보안 무제를 일으킬 수도 있다.

#### finalizer의 공격 원리

- 생성자나 직렬화 과정에서 예외가 발생하면, 이 생성되다 만 객체에서 악의적인 하위 클래서의 finalizer가 수행될 수 있게 된다.
- 이 finalizer는 정적 필드에 자신의 참조를 할당하여 가비지 컬렉터가 수집하지 못하게 막을 수 있다.

### 객체 생성을 막으려면 생성자에서 예외를 던지는 것만으로도 충분하지만, finalizer가 있따면 그렇지도 않다.

## finalizer나 cleaner를 대신하는 방법

- `AutoCloseable`을 구현해주고, 클라이언트에서 인스턴스를 다 쓰고 나면 `close` 메서드를 호출하면 된다.
- 각 인스턴스는 자신이 닫혔는지를 추적하는 것이 좋다.
  - 다시 말해, close 메서드에서 이 객체는 더 이상 유효하지 않음을 필드에 기록하고, 다른 메서드는 이 필드를 검사해서 객체가 닫힌 후에 불렸다면 `IllegalStateException`을 던지는 것이다.

## cleaner와 finalizer는 어디에 쓰이는 걸까?

1. 자원의 소유자가 close 메서드를 호출하지 않는 것에 대한 안정망 역할.
2. `네이티브 피어(native peer)`와 연결된 객체에서 사용.

> 네이티브 피어란 일반 자바 객체가 네이티브 메서드를 통해 기능을 위임한 네이티브 객체를 말한다.

- 네이티브 피어는 자바 객체가 아님으로 가비지 컬렉터는 그 존재를 알지 못한다.
- 그 결과 자바 피어를 회수할 때 네이티브 객체까지 회수하지 못한다.
- cleaner나 finalizer를 사용하기 적당한 작업이다.
