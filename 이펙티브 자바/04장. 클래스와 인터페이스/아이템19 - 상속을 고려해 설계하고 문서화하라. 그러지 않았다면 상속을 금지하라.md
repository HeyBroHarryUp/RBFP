# 상속을 고려해 설계하고 문서화하라. 그러지 않았다면 상속을 금지하라

## 상속을 고려한 설계와 문서화란?

- 메서드를 재정의하면 어떤 일이 일어나는지 정확히 정리하여 문서로 남긴다.
- 상속용 클래스는 재정의할 수 있는 메서드들은 내부적으로 어떻게 이용하는지(자기사용) 문서로 남겨야한다.
- 클래스를 안전하게 상속할 수 있도록 하려면 내부 구현 방식을 설명해야만 한다.

## 상속용 클래스 테스트

- 상속용 클래스를 시험하는 방법은 직접 하위 클래스를 만들어보는 것이 유일하다.
- 상속용으로 설계한 클래스는 배포 전에 반드시 하위 클래스를 만들어 검증해야한다.
- 상속용 클래스의 생성자는 직접적으로든 간접적으로든 재정의 가능 메서드를 호출해서는 안된다.
- 다양한 하위 클래스를 작성해보면서  **전혀 쓰이지 않는 protected 멤버는 private**이었어야 할 가능성이 크고,  **꼭 필요했을 protected 멤버를 놓쳤다면 확연히 드러날 것**이다.
- **3개 정도의 하위 클래스를 통해 검증**을 하면 적당할 것이고, 이 중  **하나 이상은 제 3자에 의해 작성**되어봐야 할 것이다.

## 상속용이 아니라면 상속을 금지해라

위의 다양한 문제들을 해결하는 가장 좋은 방법은  **상속용으로 설계하지 않은 클래스는 상속을 금지**하는 것이다.

**상속을 금지하는 방법**은 크게 두 가지다.

1.  **클래스를 final로**  선언하라.
2.  **모든 생성자를 private나 package-private로 선언**하고,  **public 정적 팩터리**를 만들어주어라.
    1.  내부에서 다양한 하위 클래스를 만들어 쓸 수 있는 유연성을 준다.

상속을 금지하더라도 Set, List, Map처럼  **상속이 불가능하더라도 개발에 큰 어려움 없이 제공가능**하다.

**래퍼 클래스 패턴**  역시 기능을 확장할 때 상속 대신 쓸 수 있는 더 나은 대안이다

## **클래스 상속을 허용해야 한다면**

구체 클래스가 표준 인터페이스를 구현하지 않았는데 상속을 금지하면 사용하기에 상당히 불편해진다.

이 때  **상속을 허용하기 위해**  아래와 같이 해보자.

1.  **클래스 내부에서는 재정의 가능 메서드를 사용하지 않게**  만들고, 이를 문서에 작성해라.
    1.  재정의 가능 메서드를 호출하는  **자기 사용 코드를 완벽히 제거**해라.
2.  **재정의 가능 메서드를 사용하는 코드를 제거**해라.
    1.  **재정의 가능 메서드는 자신의 본문 코드를 private으로**  옮기고, 이를 호출하도록 수정해라.

## Cloneable, Serializable

이 두개의 인터페이스는 상속용 설계에 한층 어려움을 더해준다. 둘 중 하나라도 구현한 클래스를 상속할 수 있게 설계하는 것은 일반적으로 좋지 않은 생각이다.  
clone과 readObject 메서드는 생성자와 비슷한 효과를 낸다. 즉, clone과 readObject 모두 직접적으로든 간접적으로든 재정의 가능 메서드를 호출해서는 안된다.