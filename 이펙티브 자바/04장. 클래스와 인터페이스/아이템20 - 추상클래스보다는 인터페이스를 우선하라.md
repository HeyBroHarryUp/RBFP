# 사전지식

## 추상 클래스

### 추상 클래스란?

추상클래스는 A, B, C라는 3개의 클래스가 있다면, A, B, C 클래스들 간에 비슷한 필드와 메서드를 공통적으로 추출해 만들어진 클래스이다.  
예를 들어 A 클래스는 사자, B 클래스는 참새, C 클래스는 강아지라고 하자. 여기서 공통적인 메서드로는 먹다라는 메서드가 있을 것이다. 그럼 이 메서드를 추출해서 추상 클래스 안에 두면 된다.  
A, B, C는 실체 클래스로 실체가 드러나는 클래스이다. 추상 클래스는 실체 클래스의 공통적인 부분을 추출해 규격만 잡아놓은 추상적인 클래스이다.  
따라서 실체 클래스는 실제 객체를 생성할 정도로 구체성을 가지는 반면, **추상 클래스는 아직 메서드와 내용이 추상적이기 때문에 객체를 생성할 수 없게 만들었다.**

### 예제 코드
```java
public abstract class Animal {
	public String kind;

	public void breath() {
		System.out.println("숨 쉰다.);
	}
	// 추상 메서드
	public abstract void sound(); // 구체적인 구현부가 없다!
}
```
Animal 이라는 추상 클래스이다. class 앞에 `abstract` operation이 있다.  
구현을 강제하는 메서드 앞에도 abstract를 붙이면 이 클래스를 상속하는 자식 클래스는 반드시 추상 메서드를 구현하도록 강제한다.
```java
public class Dog extends Animal{
	public Dog() {
		this.kind = "포유류";
	}
	@Override
	public void sound() {
	`System.out.println(``"왈왈!"``);`
	}
}
```
`extends` operation을 통해 추상 클래스를 상속받을 수 있다.  
sound() 클래스는 반드시 Override하여 재정의해야한다.

### 추상 클래스 정리
1. 추상 클래스는 실체 클래스의 공통적인 부분(변수, 메서드)를 추출해서 선언한 클래스이다.
2. 추상 클래스는 객체를 생성할 수 없다. (아직 실체성이 없고 구체적이지 않기 때문이다.)
3. 추상 클래스와 실체 클래스는 **상속 관계**이다.

## 인터페이스
```java
public interface 인터페이스명 {
	// 상수
	타입 상수명 = 값;
	
	// 추상 메서드
	타입 메서드명(매개변수, ...);
	
	// default 메서드
	default 타입 메서드명(매개변수, ...) {
		// 구현부
	}
	
	// 정적 메서드
	static 타입 메서드명(매개변수, ...) {
		// 구현부
	}
}
```

`상수` : 인터페이스에서 값을 정해줄테니 함부로 바꾸지 말고 제공해주는 값만 참조해라  (절대적)  
`추상메소드` : 가이드만 줄테니 추상메소드를 오버라이팅해서 재구현해라.  (강제적)  
`디폴트메소드` : 인터페이스에서 기본적으로 제공해주지만, 맘에 안들면 각자 구현해서 써라.  (선택적)  
`정적메소드` : 인터페이스에서 제공해주는 것으로 무조건 사용  (절대적)  

참고로 절대적이란 정말 아무것도 손댈 수 없음을 의미하고, 강제적이란 그래도 인터페이스를 implements하지 않으면 피할수는 있기에 강제적이라고 표현했다. 강제성이 있다고 해서 절대적인 것은 아니니.....

참고자료: [Limky 삽질블로그](https://limkydev.tistory.com/197)


# 추상클래스보다는 인터페이스를 우선하라

- 자바가 제공하는 다중 구현 메커니즘은 인터페이스와, 추상 클래스 두 가지가 있다.
- 자바 8부터 인터페이스도 `디폴트 메서드(default method)`를 제공할 수 있게 되어 이제는 두 메커니즘 모두 인스턴스 메서드를 구현 형태로 제공할 수 있다.
- 둘의 가장 큰 차이는 추상 클래스가 정의한 타입을 구현하는 클래스는 반드시 추상 클래스의 하위 클래스가 되어야 한다는 점이다.
- 자바는 단일 상속만 지원하니, 추상 클래스 방식은 새로운 타입을 정의하는 데 커다란 제약을 안게 된 셈이다.
- 반면 인터페이스가 선언한 메서드를 모두 정의하고 그 일반 규약을 잘 지킨 클래슥라면 다른 어떤 클래스를 상속했든 같은 타입으로 취급된다.

## 인터페이스의 장점

### 1. 기존 클래스에도 손쉽게 새로운 인터페이스를 구현해 넣을 수 있다.

- 인터페이스가 요구하는 메서드를 (아직 없다면) 추가하고, 클래스 선언에 implements 구문만 추가하면 끝이다.
- 반면 기존 클래스 위에 새로운 추상 클래스를 끼워 넣기는 어려운 게 일반적이다.
	- 두 클래스가 같은 추상 클래스를 확장하길 원한다면, 그 추상클래스는 계층 구조상 두 클래스의 공통 조상이 되어야 한다.
	- 이 방식은 클래스 계층 구조에 커다란 혼란을 일으킨다.

### 2. 인터페이스는 믹스인(mixin) 정의에 안성맞춤이다.

- `믹스인`이란 클래스가 구현할 수 있는 타입으로, 믹스인을 구현한 클래스에 원래의 '주된 타입' 외에도 특정 선택적 행위를 제공한다고 선언하는 효과를 준다.

### 3. 인터페이스로는 계층 구조가 없는 타입 프레임워크를 만들 수 있다.

- 타입을 계층적으로 정의하면 수많은 개념을 구족적으로 잘 표현할 수 있지만, 현실에는 계층을 엄격히 구분하기 어려운 갠며도 있다.
- 예를 들어 가수(Singer) 인터페이스와 작곡가(Songwriter) 인터페이스가 있다고 해보자.
- 우리 주변에는 작곡도 하는 가수가 제법 있다.
- 이 처럼 인터페이스로 정의하면 가수 클래스가 Singer와 Songwriter 모두를 구현해도 전혀 문제되지 않는다.
- 심지어 Singer와 Songwriter 모두를 확장하고 새로운 메서드까지 추가한 제 3의 인터페이스를 정의할 수도 있다.

```java
public interface Singer {
	AudioClip sing(Song s);
}
```
```java
public interface Songwriter {
	Songe compose(int charPosition);
}
```
```java
public interface SingerSongwriter extends Singer, Songwriter {
	AudioClip strum();
	void actSensitive();
}
```

### 4. 인터페이스의 메서드 중 구현 방법이 명백한 것이 있다면, 그 구현을 디폴트 메서드로 제공해 프로그래머들의 일감을 덜어줄 수 있다.

- default 메서드를 제공할 때는 상속하려는 사람을 위한 설명을 `@implSpec` 자바독 태그를 붙여 문서화해야 한다.
- **equals와 hashCode와 같은 Object의 메서드를 default 메서드로 제공해서는 안된다.**

### 5. 템플릿 메서드 패턴을 이용할 수 있다.

## 인터페이스를 구현한 클래스 이름 명명법
- 관례상 인터페이스 이름이 *Interface* 라면 구현 클래스 이름은 *AbstractInterface* 로 짓는다.
- 좋은 예로 컬렉션 프레임워크의 AbstractCollection, AbstractSet, AbstractList, AbstractMap 각각이 바로 핵심 컬렉션 인터페이스의 골격 구현이다.